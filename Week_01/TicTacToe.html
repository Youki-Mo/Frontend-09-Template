<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TicTacToe</title>
  <style type="text/css">
    .box {
      display: inline-block;
      border: 1px solid gray;
    }
    .list {
      display: flex;
    }
    .list + .list {
      border-top: 1px solid gray;
    }
    .item {
      width: 50px;
      height: 50px;
      text-align: center;
      line-height: 49px;
      font-size: 28px;
    }
    .item + .item {
      border-left: 1px solid gray;
    }
  </style>
</head>
<body>
  <div class="box"></div>
  <div>
    <button onclick="init()">init</button>
  </div>
  <script>
    const guid = 3; // 格子
    const line = 3; // 连线长度
    const pattern = []; // 棋盘数据
    const box = document.getElementsByClassName('box')[0]; // 棋盘
    const fragment = document.createDocumentFragment();
    const len = guid*guid;
    let type = 2;
    let isWin = false;
    // 生成棋盘初始数据
    function init() {
      type = 2;
      isWin = false;
      for(let i=0; i<len; i++) {
        pattern[i] = 0;
      }
      show();
    }
    // 生成棋盘
    function show() {
      box.innerHTML = '';
      for(let i=0; i<guid; i++) {
        const list = document.createElement('div');
        list.className = 'list';
        for(let j=0; j<guid; j++) {
          const item = document.createElement('div');
          item.className = 'item';
          item.innerText = pattern[i*guid+j] === 1 ? 'O' : pattern[i*guid+j] === 2 ? 'X' : '';
          item.addEventListener('click', () => move(j, i));
          list.appendChild(item);
        }
        fragment.appendChild(list);
      }
      box.appendChild(fragment);
    };
    // 生成棋子
    function move(x, y) {
      let n = y*guid+x;
      if (pattern[n] === 0 && !isWin) {
        pattern[n] = type;
        show();
        if (check(pattern, type, n)) {
          alert(`${type === 1 ? 'O' : 'X'} 赢了`);
          isWin = true;
          return;
        }
        type = 3 - type;
        aiMove(n);
      }
    }
    function aiMove(n) {
      let choice = bestChoice(pattern, 3-type, n);
      console.log(choice);
      if (!(choice.point >= 0)) return;
      pattern[choice.point] = type;
      show();
      type = 3 - type;
      if (check(pattern, type, n)) {
        alert(`${type === 1 ? 'O' : 'X'} 赢了`);
        isWin = true;
        return;
      }
    }
    // 胜负判断
    function check(pattern, type, n) {
      for(let i=0; i<line; i++) {
        // 判断行← →
        let x = n-i;
        if (x>=0) {
          if (i===0 && guid-x%guid >= line) continue; // 如果换行了，直接跳出本次循环
          let win = true;
          for(let j=0; j<line; j++) {
            (x+j>=len || pattern[x+j] !== type) && (win = false);
          }
          if (win) return true;
        }
        // 判断列↑ ↓
        x = n-i*guid;
        if (x >= 0) {
          let win = true;
          for(let j=0; j<line; j++) {
            (x+j*guid>=len || pattern[x+j*guid] !== type) && (win = false);
          }
          if (win) return true;
        }
        // 判断斜线 左上右下↖↘
        x = n-i*(guid+1);
        if (x >= 0 && x%guid < line-1) {
          if (i===0 && guid-x%guid >= line) continue;
          let win = true;
          for(let j=0; j<line; j++) {
            (x+j*(guid+1)>=len || pattern[x+j*(guid+1)] !== type) && (win = false);
          }
          if (win) {
            return true;
          }
          
        }
        // 判断斜线 左下右上↙↗
        x = n-i*(guid-1);
        if (x >= 0 && x%guid >= line-1) {
          if (i===0 && guid-x%guid < line) continue;
          let win = true;
          for(let j=0; j<line; j++) {
            (x+j*(guid-1)>=len || pattern[x+j*(guid-1)] !== type) && (win = false);
          }
          if (win)  return true;
        }
      }
      return false;
    }
    function clone(pattern) {
      return Object.create(pattern);
    }
    function willWin(pattern, type, n) {
      for(let i=0; i<line; i++) {
        // 判断行← →
        let x = n-i;
        if (x>=0) {
          for(let j=0; j<line; j++) {
            if (x+j>=len || pattern[x+j]) continue;
            const arr = clone(pattern);
            arr[x+j] = type;
            if(check(arr, type, x+j)) return x+j;
          }
        }
        // 判断列↑ ↓
        x = n-i*guid;
        if (x >= 0) {
          for(let j=0; j<line; j++) {
            if (x+j*guid>=len || pattern[x+j*guid]) continue;
            const arr = clone(pattern);
            arr[x+j*guid] = type;
            if(check(arr, type, x+j*guid)) return x+j*guid;
          }
        }
        // 判断斜线 左上右下↖↘
        x = n-i*(guid+1);
        if (x >= 0) {
          for(let j=0; j<line; j++) {
            if (x+j*(guid+1)>=len || pattern[x+j*(guid+1)]) continue;
            const arr = clone(pattern);
            arr[x+j*(guid+1)] = type;
            if(check(arr, type, x+j*(guid+1))) return x+j*(guid+1);
          }
        }
        // 判断斜线 左下右上↙↗
        x = n-i*(guid-1);
        if (x >= 0) {
          for(let j=0; j<line; j++) {
            if (x+j*(guid-1)>=len || pattern[x+j*(guid-1)]) continue;
            const arr = clone(pattern);
            arr[x+j*(guid-1)] = type;
            if(check(arr, type, x+j*(guid-1))) return x+j*(guid-1);
          }
        }
      }
      return -1;
    }
    function bestChoice(pattern, type, n, reckon = 1000) {
      if (reckon <= 0) return { point: n, result: 0 };
      reckon--;
      let p = willWin(pattern, type, n);
      // 判断p大于等于0时已经有胜的落子，拿到返回的坐标值并返回result=1
      if (p>=0) {
        return {
          point: p,
          result: 1
        }
      }
      let result = -2, point = null;
      // 穷举当前落子可能组成胜棋的位置
      outer:for(let i=0; i<line; i++) {
        // 判断行← →
        let x = n-i;
        if (x < 0) continue;
        for(let j=0; j<line; j++) {
          if (x+j>=len || pattern[x+j]) continue;
          const arr = clone(pattern);
          arr[x+j] = type;
          let r = bestChoice(arr, type, x+j, reckon).result;
          if (-r > result) {
            result = -r;
            point = x+j;
          }
          if (result == 1) break outer;
        }
        // 判断列↑ ↓
        x = n-i*guid;
        if (x < 0) continue;
        for(let j=0; j<line; j++) {
          if (x+j*guid>=len || pattern[x+j*guid]) continue;
          const arr = clone(pattern);
          arr[x+j*guid] = type;
          let r = bestChoice(arr, type, x+j*guid, reckon).result;
          if (-r > result) {
            result = -r;
            point = x+j*guid;
          }
          if (result == 1) break outer;
        }
        
        // 判断斜线 左上右下↖↘
        x = n-i*(guid+1);
        if (x < 0) continue;
        for(let j=0; j<line; j++) {
          if (x+j*(guid+1)>=len || pattern[x+j*(guid+1)]) continue;
          const arr = clone(pattern);
          arr[x+j*(guid+1)] = type;
          let r = bestChoice(arr, type, x+j*(guid+1), reckon).result;
          if (-r > result) {
            result = -r;
            point = x+j*guid;
          }
          if (result == 1) break outer;
        }
        // 判断斜线 左下右上↙↗
        x = n-i*(guid-1);
        if (x < 0) continue;
        for(let j=0; j<line; j++) {
          if (x+j*(guid-1)>=len || pattern[x+j*(guid-1)]) continue;
          const arr = clone(pattern);
          arr[x+j*(guid-1)] = type;
          let r = bestChoice(arr, type, x+j*(guid-1), reckon).result;
          if (-r > result) {
            result = -r;
            point = x+j*guid;
          }
          if (result == 1) break outer;
        }
      }
      return {
        point,
        result: point && point !== 0 ? result : 0
      }
    }
    init();
  </script>
</body>
</html>